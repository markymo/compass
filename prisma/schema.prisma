generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id        String       @id @default(uuid())
  email     String       @unique
  name      String?
  description String?    @db.Text
  createdAt DateTime     @default(now())
  
  // Auth.js support
  password      String?
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  
  // Replaced orgRoles with polymorphic memberships
  memberships Membership[]
  
  comments  Comment[]
  activities QuestionActivity[]
  
  // Admin Todo Relations
  assignedTodos AdminTodo[] @relation("AssignedTodos")
  createdTodos  AdminTodo[] @relation("CreatedTodos")
  adminComments AdminTodoComment[]
  
  engagementActivities EngagementActivity[]
  auditLogs       AuditLog[]
  
  // Demo Capability
  isDemoActor     Boolean        @default(false)
  
  assignedQuestions Question[] @relation("AssignedQuestions")
}

model Organization {
  id             String          @id @default(uuid())
  name           String
  types          OrgType[]
  domain         String?
  logoUrl        String?
  description    String?         @db.Text
  status         String          @default("ACTIVE") // ACTIVE, ARCHIVED
  metadata       Json?           // Flexible store for stats (League Tables etc)
  // clientLEs replaced by ownedLEs
  engagements    FIEngagement[]
  fiSchemas      FISchema[]
  questionnaires      Questionnaire[] 
  ownedQuestionnaires Questionnaire[] @relation("OwnedQuestionnaires")
  
  // Replaced members with memberships (Party Scope)
  memberships    Membership[]

  // New Ownership Model
  ownedLEs       ClientLEOwner[]
  

  
  customFieldDefinitions CustomFieldDefinition[]
}

// POLYMORPHIC MEMBERSHIP (Party OR Workspace)
model Membership {
  id             String        @id @default(uuid())
  userId         String
  
  // Scope A: Organization (The Party: Client or Supplier)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id])
  
  // Scope B: ClientLE (The Workspace: Project Company / SPV)
  clientLEId     String?
  clientLE       ClientLE?     @relation(fields: [clientLEId], references: [id])
  
  role           String        // e.g. "REV_ADMIN", "CONTRIBUTOR", "AID_ADVISOR"
  permissions    Json?         // Optional granular overrides
  
  user           User          @relation(fields: [userId], references: [id])
  
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // A user can have only one role per scope instance
  @@unique([userId, organizationId, clientLEId])
}

model MasterSchema {
  id         String           @id @default(uuid())
  version    Int
  isActive   Boolean          @default(false)
  definition Json
  createdAt  DateTime         @default(now())
  records    ClientLERecord[]
  fiSchemas  FISchema[]
}

model FISchema {
  id                String       @id @default(uuid())
  fiOrgId           String
  masterSchemaId    String
  overlayDefinition Json
  fi                Organization @relation(fields: [fiOrgId], references: [id])
  masterSchema      MasterSchema @relation(fields: [masterSchemaId], references: [id])
}

model CustomFieldDefinition {
  id             String        @id @default(uuid())
  orgId          String
  key            String        // Machine-readable key (e.g. "esg_score")
  label          String        // Human-readable label (e.g. "ESG Score")
  dataType       String        // "STRING", "NUMBER", "DATE", "BOOLEAN"
  description    String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  organization   Organization  @relation(fields: [orgId], references: [id])
  questions      Question[]

  @@unique([orgId, key])
}

model StandingDataSection {
  id        String   @id @default(uuid())
  clientLEId String
  clientLE   ClientLE @relation(fields: [clientLEId], references: [id], onDelete: Cascade)
  category  String   // E.g., "CORE", "STRUCTURE", "GEOGRAPHY", etc.
  content   String   @db.Text // Markdown content
  updatedAt DateTime @updatedAt
  
  @@unique([clientLEId, category])
}

model ClientLE {
  id           String             @id @default(uuid())
  name         String
  description  String?            @db.Text
  jurisdiction String?
  status       String             @default("ACTIVE")
  isDeleted    Boolean            @default(false)
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  records      ClientLERecord[]
  fiEngagements FIEngagement[]
  standingDataSections StandingDataSection[]
  documents     Document[]
  
  // LEI & GLEIF Integration
  lei           String?            @unique
  gleifData     Json?              // Raw/Canonical response from GLEIF
  gleifFetchedAt DateTime?
  
  // Phase 2 Bridge
  identityProfile IdentityProfile?

  // National Registry Data (e.g. Companies House)
  nationalRegistryData Json?     // "Mother" Directory Data
  registryFetchedAt    DateTime?
  
  // Billing & Invoicing
  billingDetails       Json?     // Flexible store for Address, VAT, PO, Contacts
  
  // Workspace Memberships (Direct Access)
  memberships   Membership[]

  // Ownership History (New Multi-Owner Model)
  owners        ClientLEOwner[]
  

  
  customData    Json?
}

model ClientLEOwner {
  id           String       @id @default(uuid())
  clientLEId   String
  clientLE     ClientLE     @relation(fields: [clientLEId], references: [id], onDelete: Cascade)
  
  partyId      String       // The Client Org
  party        Organization @relation(fields: [partyId], references: [id])
  
  startAt      DateTime     @default(now())
  endAt        DateTime?    // Null = Current Owner
  
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@index([clientLEId])
  @@index([partyId])
}

model ClientLERecord {
  id             String       @id @default(uuid())
  clientLEId     String
  masterSchemaId String
  data           Json
  status         RecordStatus
  updatedAt      DateTime     @updatedAt
  clientLE       ClientLE     @relation(fields: [clientLEId], references: [id])
  masterSchema   MasterSchema @relation(fields: [masterSchemaId], references: [id])
}

model FIEngagement {
  id             String           @id @default(uuid())
  fiOrgId        String
  clientLEId     String
  status         EngagementStatus
  isDeleted      Boolean          @default(false)
  clientLE       ClientLE         @relation(fields: [clientLEId], references: [id])
  org            Organization     @relation(fields: [fiOrgId], references: [id])
  queries        Query[]
  questionnaires Questionnaire[]  @relation("FIEngagementToQuestionnaire") // Templates
  questionnaireInstances Questionnaire[] @relation("QuestionnaireInstance") // Instances

  @@unique([fiOrgId, clientLEId])
  sharedDocuments Document[] @relation("SharedDocuments") // Access Granted
  activities      EngagementActivity[]
  invitations     Invitation[]
}

model EngagementActivity {
  id             String       @id @default(uuid())
  fiEngagementId String
  userId         String
  type           String       // INVITE_SENT, CONNECTED, SNAPSHOT_CHANGE
  details        Json?
  createdAt      DateTime     @default(now())

  engagement     FIEngagement @relation(fields: [fiEngagementId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id])
}

model Document {
  id              String         @id @default(uuid())
  clientLEId      String
  name            String
  fileUrl         String         // Path to storage (or mock URL)
  fileType        String         // mime type e.g. 'application/pdf'
  kbSize          Int?           // Size in KB
  docType         String?        // 'IDENTITY', 'CORPORATE'
  metadata        Json?          // { expiry: "2025-12-31" }
  isVerified      Boolean        @default(false)
  isDeleted       Boolean        @default(false)
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  clientLE        ClientLE       @relation(fields: [clientLEId], references: [id])
  sharedWith      FIEngagement[] @relation("SharedDocuments")
}

model Query {
  id             String       @id @default(uuid())
  fiEngagementId String
  fieldKey       String
  question       String
  answer         String?
  status         QueryStatus
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  engagement     FIEngagement @relation(fields: [fiEngagementId], references: [id])
}

model Questionnaire {
  id               String         @id @default(uuid())
  fiOrgId          String
  name             String
  status           String         @default("DRAFT")
  isDeleted        Boolean        @default(false)
  fileName         String?
  fileType         String?
  fileContent      Bytes?
  mappings         Json?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  extractedContent Json?
  rawText          String?        @db.Text
  processingLogs   Json?          // Array of { timestamp, stage, message, level }
  fiOrg            Organization   @relation(fields: [fiOrgId], references: [id])
  engagements      FIEngagement[] @relation("FIEngagementToQuestionnaire")

  // Link to Engagement (For Instances/Snapshots)
  fiEngagementId   String?
  fiEngagement     FIEngagement?  @relation("QuestionnaireInstance", fields: [fiEngagementId], references: [id])
  
  // Privacy: If set, this questionnaire is only visible to this Org (and System Admins)
  ownerOrgId       String?
  ownerOrg         Organization?  @relation("OwnedQuestionnaires", fields: [ownerOrgId], references: [id])
  isGlobal         Boolean        @default(false)
  versions         QuestionnaireVersion[]
  questions        Question[]
}

model Question {
  id              String             @id @default(uuid())
  questionnaireId String
  text            String
  compactText     String?            // Compact version (â‰¤20 chars) for kanban display
  answer          String?            @db.Text
  status          QuestionStatus     @default(DRAFT)
  isLocked        Boolean            @default(false)
  order           Int                @default(0)
  // Link to Master Data
  masterFieldNo          Int?               // Direct 1:1 link to FieldDefinitions
  masterQuestionGroupId  String?            // Composite 1:N link to FieldGroups

  // Link to Ad-Hoc Custom Data
  customFieldDefinitionId String?
  customFieldDefinition   CustomFieldDefinition? @relation(fields: [customFieldDefinitionId], references: [id])

  // Link to Standing Data (if auto-filled)
  sourceSectionId String?
  
  assignedToUserId String?
  assignedToUser   User?              @relation("AssignedQuestions", fields: [assignedToUserId], references: [id])
  assignedEmail    String?
  
  questionnaire   Questionnaire      @relation(fields: [questionnaireId], references: [id], onDelete: Cascade)
  comments        Comment[]
  activities      QuestionActivity[]
  
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
}

model Comment {
  id         String   @id @default(uuid())
  questionId String
  userId     String
  text       String   @db.Text
  type       String   @default("USER") // USER, AI, SYSTEM
  createdAt  DateTime @default(now())
  
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id])
}

model QuestionActivity {
  id         String   @id @default(uuid())
  questionId String
  userId     String
  type       String   // AI_GENERATED, ANSWER_UPDATED, LOCKED, UNLOCKED, ASSIGNED
  details    Json?    // Store 'previousValue', 'newValue', 'confidence', etc.
  createdAt  DateTime @default(now())

  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id])
}

enum QuestionStatus {
  DRAFT
  INTERNAL_REVIEW
  SHARED
  SUPPLIER_REVIEW
  QUERY
  CLIENT_SIGNED_OFF
  SUPPLIER_SIGNED_OFF // Final
}

model QuestionnaireVersion {
  id              String        @id @default(uuid())
  questionnaireId String
  versionNumber   Int
  snapshotData    Json
  pdfContent      Bytes
  createdAt       DateTime      @default(now())
  questionnaire   Questionnaire @relation(fields: [questionnaireId], references: [id], onDelete: Cascade)
}

enum OrgType {
  CLIENT
  FI
  SYSTEM
  LAW_FIRM
}

enum RecordStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum EngagementStatus {
  PREPARATION
  INVITED
  CONNECTED
  ARCHIVED
}

enum QueryStatus {
  OPEN
  RESOLVED
}

model UsageLog {
  id        String   @id @default(uuid())
  userId    String
  action    String
  path      String?
  details   Json?
  createdAt DateTime @default(now())

  @@index([userId])
}

model AdminTodo {
  id               String             @id @default(uuid())
  title            String
  description      String?            @db.Text
  status           AdminTodoStatus    @default(BACKLOG)
  dueDate          DateTime?
  assignedToUserId String?
  createdByUserId  String
  
  assignedToUser   User?              @relation("AssignedTodos", fields: [assignedToUserId], references: [id])
  createdByUser    User               @relation("CreatedTodos", fields: [createdByUserId], references: [id])
  
  comments         AdminTodoComment[]
  
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  
  isDeleted        Boolean            @default(false)
  isArchived       Boolean            @default(false)
}

model AdminTodoComment {
  id          String    @id @default(uuid())
  adminTodoId String
  userId      String
  text        String    @db.Text
  createdAt   DateTime  @default(now())
  
  adminTodo   AdminTodo @relation(fields: [adminTodoId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id])
}

enum AdminTodoStatus {
  BACKLOG
  DRAFTING
  IN_PROGRESS
  DONE
}

  // Organization invitations relation removed
  // clientLE invitations relation removed
  // fiEngagement invitations relation updated to match new field name if needed (it was fiEngagementId, so it's fine)

  // Actually, I can just remove the relation fields in Org/ClientLE.

model Invitation {
  id                String   @id @default(uuid())

  fiEngagementId    String
  fiEngagement      FIEngagement @relation(fields: [fiEngagementId], references: [id], onDelete: Cascade)

  sentToEmail       String
  role              String   // e.g. "Contact", "Compliance", "Reviewer"

  tokenHash         String   @unique
  expiresAt         DateTime
  usedAt            DateTime?
  revokedAt         DateTime?

  createdByUserId   String
  acceptedByUserId  String?

  createdAt         DateTime @default(now())
  
  // Relations to User for audit? 
  // User spec didn't strictly ask for FKs to User, just IDs. 
  // Given "Relationship exists before users", maybe invitedBy is a valid User.
  // I'll stick to String IDs to avoid circular deps or complex delete cascades for now, unless User spec implied FK. 
  // "createdByUserId String" suggests scalar.
}



model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  action    String
  entityId  String?
  details   Json?
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([entityId])
}

// ============================================================================
// Phase 2A: KYC Data Model Enums
// ============================================================================

enum EvidenceProvider {
  GLEIF
  COMPANIES_HOUSE
  USER_UPLOAD
}

enum DocumentOwnerType {
  LEGAL_ENTITY
  STAKEHOLDER
  AUTHORIZED_TRADER
}

enum StakeholderType {
  INDIVIDUAL
  CORPORATE
}

enum StakeholderRole {
  DIRECTOR
  UBO
  CONTROLLER
}

enum ContactType {
  NOTICE
  PROCESS_AGENT
  OFFICE
  PORTFOLIO_DATA
  DISCREPANCY
  DISPUTE
}

// ============================================================================
// Phase 2A: KYC Data Model Tables
// Schema-only migration - creates empty tables for new KYC data model
// No existing data is moved or modified in this phase
// ============================================================================

// ----------------------------------------------------------------------------
// Core Tables (Foundation)
// ----------------------------------------------------------------------------

model LegalEntity {
  id        String   @id @default(uuid())
  reference String   @unique // Public identifier
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1:1 Profiles
  identityProfile       IdentityProfile?
  entityInfoProfile     EntityInfoProfile?
  leiRegistration       LeiRegistration?
  relationshipProfile   RelationshipProfile?
  constitutionalProfile ConstitutionalProfile?
  complianceProfile     ComplianceProfile?
  taxProfile            TaxProfile?
  financialProfile      FinancialProfile?
  derivativesProfile    DerivativesProfile?
  tradingProfile        TradingProfile?
  contactProfile        ContactProfile?

  // 1:N Repeating
  entityNames             EntityName[]
  industryClassifications IndustryClassification[]
  stakeholders            Stakeholder[]
  taxRegistrations        TaxRegistration[]
  authorizedTraders       AuthorizedTrader[]
  contacts                Contact[]
  settlementInstructions  SettlementInstruction[]

  // Documents
  documents DocumentRegistry[]
  
  // Audit Log
  masterDataEvents MasterDataEvent[]

  @@map("legal_entities")
}

model EvidenceStore {
  id            String           @id @default(uuid())
  hash          String           @unique // SHA-256 for deduplication
  provider      EvidenceProvider
  payload       Json // Immutable source data (GLEIF, Companies House, etc.)
  schemaVersion String
  retrievedAt   DateTime
  capturedBy    String? // User ID

  createdAt DateTime @default(now())

  // Audit Log
  masterDataEvents MasterDataEvent[]

  @@index([hash])
  @@index([provider])
  @@map("evidence_store")
}

model DocumentRegistry {
  id            String            @id @default(uuid())
  legalEntityId String
  ownerType     DocumentOwnerType
  ownerId       String // Polymorphic: LegalEntity, Stakeholder, or AuthorizedTrader ID
  fieldNo       Int // Traceability to Master Schema Field No
  filePath      String // S3 key or storage reference
  fileName      String
  mimeType      String
  uploadedAt    DateTime @default(now())
  uploadedBy    String // User ID

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@index([ownerType, ownerId])
  @@index([fieldNo])
  @@map("document_registry")
}

// ----------------------------------------------------------------------------
// 1:1 Profile Modules
// Each profile stores canonical current values for its domain
// Original source data preserved in evidence_store
// Provenance tracked via meta.evidence_id
// ----------------------------------------------------------------------------

model IdentityProfile {
  id            String @id @default(uuid())
  legalEntityId String? @unique

  // Fields 1-3, 6-10, 11-15, 26-27
  leiValidationDate  DateTime?
  leiCode            String?
  legalName          String?
  regAddressLine1    String?
  regAddressCity     String?
  regAddressRegion   String?
  regAddressCountry  String?
  regAddressPostcode String?
  hqAddressLine1     String?
  hqAddressCity      String?
  hqAddressRegion    String?
  hqAddressCountry   String?
  hqAddressPostcode  String?
  entityStatus       String?
  entityCreationDate DateTime?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity? @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  // Bridge for Hybrid Adoption (Phase 2E)
  clientLEId String? @unique
  clientLE   ClientLE? @relation(fields: [clientLEId], references: [id])

  @@map("identity_profiles")
}

model EntityInfoProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 19-25
  gleifEntityCategory                   String?
  entityLegalFormCode                   String? // ELF
  countryOfFormation                    String?
  countryCode                           String? // ISO 3166-1
  entityLegalFormLocalName              String?
  entityLegalFormTransliteratedName     String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("entity_info_profiles")
}

model LeiRegistration {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 28-35
  leiRegistrationDate       DateTime?
  leiRegistrationUpdateDate DateTime?
  leiRegistrationStatus     String?
  leiRegistrationNextRenewal DateTime?
  leiIssuerLei              String?
  leiIssuer                 String?
  leiCorroborationLevel     String?
  leiCorroborationSource    String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("lei_registrations")
}

model RelationshipProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 36-55
  directParentId                 String?
  directParent                   String?
  directParentIdType             String?
  directParentRelationship       String?
  ultimateParentId               String?
  ultimateParent                 String?
  ultimateParentIdType           String?
  ultimateParentRelationship     String?
  fundManagerId                  String?
  fundManager                    String?
  fundManagerIdType              String?
  fundManagerRelationship        String?
  fundManagerRelationshipStatus  String?
  umbrellaFundId                 String?
  umbrellaFund                   String?
  umbrellaFundIdType             String?
  umbrellaFundRelationship       String?
  umbrellaFundRelationshipStatus String?
  leiDirectParentException       String?
  leiUltimateParentException     String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("relationship_profiles")
}

model ConstitutionalProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 16-18, 57-59
  registrationAuthorityGleifId String?
  registrationAuthority        String?
  registeredNumber             String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("constitutional_profiles")
}

model ComplianceProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 75-80
  operatingCountries Json? // Array of country codes
  highRiskCountries  Json? // Array of country codes
  highRiskSectors    Json? // Array of sector codes
  ukSanctionsCheck   String? // FALSE or description
  euSanctionsCheck   String? // FALSE or description
  ofacSanctionsCheck String? // FALSE or description

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("compliance_profiles")
}

model TaxProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Field 83 (FATCA status only)
  // Note: Fields 82 (W-8BEN-E) and 84 (CRS Self-Certification) are document-only
  fatcaStatus String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("tax_profiles")
}

model FinancialProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 85-90
  lastAccountsMadeUpTo DateTime?
  nextAccountingDate   DateTime?
  nextAccountsDueDate  DateTime?
  lastStatementDate    DateTime?
  nextStatementDate    DateTime?
  nextStatementDueDate DateTime?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("financial_profiles")
}

model DerivativesProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 91-93, 110-112 (document references)
  isdaMasterRegulatoryDisclosureLetterRef String? // Doc ID
  isdaEmirClassificationLetterRef         String? // Doc ID
  isdaUsSelfdisclosureLetterRef           String? // Doc ID
  isdaReportingDelegationAgreementRef     String? // Doc ID
  isdaFiaEmirReportingDelegationRef       String? // Doc ID
  isda2013ReportingProtocolSideLetterRef  String? // Doc ID

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("derivatives_profiles")
}

model TradingProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 102-103 (board minute references)
  boardMinuteAuthorisingIndividualsRef   String? // Doc ID
  boardMinuteAuthorisingTransactionsRef  String? // Doc ID

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("trading_profiles")
}

model ContactProfile {
  id            String @id @default(uuid())
  legalEntityId String @unique

  // Fields 107-109, 113-115
  processAgent           String?
  office                 String?
  isMultibranchParty     Boolean?
  portfolioDataEmail     String?
  discrepancyNoticeEmail String?
  disputeNoticeEmail     String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@map("contact_profiles")
}

// ----------------------------------------------------------------------------
// 1:N Repeating Tables
// Multiple instances per Legal Entity
// ----------------------------------------------------------------------------

model EntityName {
  id            String @id @default(uuid())
  legalEntityId String

  // Fields 4-5
  name String
  type String // TRADING_AS, PREVIOUS, LEGAL

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@map("entity_names")
}

model IndustryClassification {
  id            String @id @default(uuid())
  legalEntityId String

  // Field 20
  code   String
  scheme String // UK_SIC, etc.

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@map("industry_classifications")
}

model Stakeholder {
  id              String          @id @default(uuid())
  legalEntityId   String
  stakeholderType StakeholderType
  role            StakeholderRole

  // Individual fields (Fields 65-68)
  fullName      String?
  dateOfBirth   DateTime?
  placeOfBirth  String?
  nationalities Json? // Array
  idDocumentId  String? // FK to DocumentRegistry

  // Corporate fields (Fields 69-73)
  legalName                    String?
  leiCode                      String?
  registrationAuthorityGleifId String?
  registrationAuthority        String?
  registeredNumber             String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@index([role])
  @@map("stakeholders")
}

model TaxRegistration {
  id            String @id @default(uuid())
  legalEntityId String

  // Field 81
  taxId   String
  country String

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@map("tax_registrations")
}

model AuthorizedTrader {
  id            String @id @default(uuid())
  legalEntityId String

  // Fields 96-101
  fullName                 String
  email                    String
  phone                    String?
  mobile                   String?
  products                 Json? // Array
  authorityDocumentId      String? // FK to DocumentRegistry (Field 100)
  authorityAttestationText String? @db.Text

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@map("authorized_traders")
}

model Contact {
  id            String      @id @default(uuid())
  legalEntityId String
  contactType   ContactType

  // Fields 104-106
  address   String? @db.Text
  attention String?
  email     String?

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@map("contacts")
}

model SettlementInstruction {
  id            String @id @default(uuid())
  legalEntityId String

  // Fields 116-119
  currency      String
  accountName   String
  accountNumber String
  ibanSwift     String

  meta      Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  legalEntity LegalEntity @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)

  @@index([legalEntityId])
  @@map("settlement_instructions")
}

model MasterDataEvent {
  id            String           @id @default(uuid())
  legalEntityId String
  fieldNo       Int
  oldValue      Json?
  newValue      Json?
  source        String
  evidenceId    String?
  actorId       String?
  reason        String?
  timestamp     DateTime         @default(now())

  legalEntity LegalEntity    @relation(fields: [legalEntityId], references: [id], onDelete: Cascade)
  evidence    EvidenceStore? @relation(fields: [evidenceId], references: [id])

  @@index([legalEntityId, fieldNo, timestamp(sort: Desc)])
  @@index([evidenceId])
  @@map("master_data_events")
}
